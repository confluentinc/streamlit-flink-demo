import sys


# Simple class extending list that encapsulates a table generated from a
# changelog. Tables support incremental updates so that callers don't have
# to consume an entire changelog each time they want to update a table.
#
# The pattern is to use the set of new changelog records returned by consume(),
# and then pass those to update(), like so:
#
#   log = Changelog(schema, rows)
#   log.consume(n)
#   table = log.collapse()
#
#   new = log.consume(n)
#   table.update(new)
#
# At this point the table will be equivalent to a table generated by scanning all
# 2 * n records in the changelog, but will not have performed any extraneous scans
# in order to reflect the new changelog records.
class Table(list):

    def __init__(self, columns):
        super().__init__()
        self.columns = columns

    def update(self, rows):
        def remove(r):
            if r not in self:
                print('no corresponding row in table to remove: %s', r)
                return
            self.remove(r)

        handlers = {
            '+I': self.append,
            '-U': remove,
            '+U': self.append,
            '-D': remove,
            None: self.append
        }
        for row in rows:
            op, row = row[0], row[1:]
            # Changelog should have already validated that these changelog records
            # contain valid op codes
            handlers[op](row)


# Lightweight wrapper around result sets returned by the API. Encapsulates
# things that are useful when dealing with result sets, such as statement
# start time (latency), schema, rows, and functionality for interpreting its
# underlying changelog.

# Callers may retrieve the raw changelog consumed thus far, which is serialized
# as a list. Each changelog element is a tuple of the form:
#
#   <op code, column1, column2, ...>
#
# Callers may also collapse the changelog consumed thus far, which will scan
# the changelog and apply inserts, updates and deletes as necessary. Tables
# may be obtained by calling the collapse() method. They have the following form:
#
#    <column1, column2, ...>
#
# These table rows are returned within a Table instance.
#
# Changelogs also inherit all in-context SET properties from when their
# corresponding statements were executed by the interpreter, giving users
# control over how they are displayed.
class Changelog(object):

    def __init__(self, schema, rows, statement=None, ts=None, properties=None):
        # It's easier to always work with generators instead of having to special
        # case arrays. If it's already a generator this is a noop. Wrapping changelog
        # records in an iterator is also good for correctness, as it ensures that this
        # changelog's history can only be scanned sequentially. If callers want to work
        # with changelog records more freely, they can simply wrap the changelog in a list.
        self.rows = rows
        self.statement = statement or {}
        self.properties = properties or {}
        self.ts = ts
        self.history = []
        # Schema associated with the raw rows encapsulated within this Changelog
        self.internal_schema = schema
        # Columns in the flattened scan result of this changelog
        self.columns = [c['name'] for c in self.internal_schema['columns']]
        self.columns.insert(0, 'op')
        # Set for keeping track of all unique valid op codes received by this changelog.
        # This is used to determine whether or not it's a real changelog. Certain API
        # responses (such as for SHOW TABLES) will not include op codes in the result.
        # However, it's convenient to treat all server responses as changelogs rather than
        # special case them, so if we have a changelog that's not a real changelog, this
        # set allows us to identify that scenario and just scan it as a table instead.
        self.ops_received = set()

    def collapse(self):
        columns = [c['name'] for c in self.internal_schema['columns']]
        result = Table(columns)
        result.update(self.history)
        return result

    def validate(self, data):
        op_labels = {
            0: '+I',
            1: '-U',
            2: '+U',
            3: '-D'
        }
        # print("[validate] data=", data, type(data))
        op = data.get('op')
        row = list(data['row'])
        # Note that we're validating incoming rows against the schema this
        # changelog was built from, not the set of columns in this changelog's
        # output (self.columns)
        if len(row) != len(self.internal_schema['columns']):
            args = (
                len(self.internal_schema['columns']),
                len(row),
                row
            )
            raise ValueError('table has %d columns but row has %d: %s' % args)
        if op is not None and op not in op_labels:
            raise ValueError('invalid op code received for row: %s' % data)

        # From this point forth, work with slightly more human friendly op codes
        if op is not None:
            op = op_labels[op]

        # Also note that we'll be working with flattened changelog rows now,
        # in which the op code is just the first column in each row
        return op, tuple([op] + list(row))

    async def consume(self, limit=None, copy=False):
        limit = limit if limit is not None else sys.maxsize
        # Changelogs always wrap rows in a generator, which make this easy.
        # Each call to consume will pick up where the last one left off in
        # the generator, so no need to keep our own cursor.
        start = len(self.history)
        consumed = 0

        async for data in self.rows:
            try:
                op, row = self.validate(data)
                self.history.append(row)
                if op:
                    self.ops_received.add(op)
                consumed += 1
                if consumed >= limit:
                    break
            except StopIteration:
                break

        # Return the newly added changelog rows in the form of a slice
        # to avoid extraneous memory consumption, unless caller wants
        # a copy (generally for thread safety)
        result = self.history[start:]
        if copy:
            result = list(result)
        return result


